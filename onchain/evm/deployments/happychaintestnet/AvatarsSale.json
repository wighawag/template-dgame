{
  "address": "0x33a0d701f0619afb407963d6b7f9781dc40f9fcf",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract Avatars",
          "name": "items",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "paymentAmount",
              "type": "uint256"
            },
            {
              "internalType": "address payable",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "freeMapAdmin",
              "type": "address"
            }
          ],
          "internalType": "struct SaleViaNativePayment.Config",
          "name": "config",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "ExpectNativeToken",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        }
      ],
      "name": "FailedToTransferNativeToken",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "expected",
          "type": "address"
        }
      ],
      "name": "NotFreeMapAdmin",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "TransferFailed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "expected",
          "type": "uint256"
        }
      ],
      "name": "WrongPaymentAmount",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "referrer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "tokenID",
          "type": "uint256"
        }
      ],
      "name": "Mint",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "FREE_MAP_ADMIN",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ITEMS",
      "outputs": [
        {
          "internalType": "contract IERC721",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "PAYMENT_AMOUNT",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "RECIPIENT",
      "outputs": [
        {
          "internalType": "address payable",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "addresses",
          "type": "address[]"
        }
      ],
      "name": "addToFreeMap",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "freemap",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address payable",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint96",
          "name": "subID",
          "type": "uint96"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "internalType": "address payable",
          "name": "extraNativeTokenRecipient",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "extraNativeTokenAmount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "referrer",
          "type": "address"
        }
      ],
      "name": "purchase",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "addresses",
          "type": "address[]"
        }
      ],
      "name": "removeFromFreeMap",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "contractName": "AvatarsSale",
  "sourceName": "src/avatars/AvatarsSale.sol",
  "bytecode": "0x610100604052348015610010575f5ffd5b50604051610c98380380610c9883398101604081905261002f91610080565b6001600160a01b03918216608052805160a0526020810151821660c052604001511660e052610118565b6001600160a01b038116811461006d575f5ffd5b50565b805161007b81610059565b919050565b5f5f8284036080811215610092575f5ffd5b835161009d81610059565b92506060601f19820112156100b0575f5ffd5b50604051606081016001600160401b03811182821017156100df57634e487b7160e01b5f52604160045260245ffd5b8060405250602084015181526100f760408501610070565b602082015261010860608501610070565b6040820152809150509250929050565b60805160a05160c05160e051610b166101825f395f81816101aa0152818161022a015281816102920152818161036f01526103d701525f8181608e01526105b101525f818161016901528181610517015261056b01525f81816101f001526107af0152610b165ff3fe608060405260043610610079575f3560e01c80636bc55ab81161004c5780636bc55ab8146101585780637baa320b14610199578063c3b1328d146101cc578063e2bf56f3146101df575f5ffd5b80630d9019e11461007d578063277af731146100da5780633ba21e7214610118578063582dc0ba14610139575b5f5ffd5b348015610088575f5ffd5b506100b07f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b3480156100e5575f5ffd5b506101086100f4366004610854565b5f6020819052908152604090205460ff1681565b60405190151581526020016100d1565b348015610123575f5ffd5b50610137610132366004610876565b610212565b005b348015610144575f5ffd5b50610137610153366004610876565b610357565b348015610163575f5ffd5b5061018b7f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020016100d1565b3480156101a4575f5ffd5b506100b07f000000000000000000000000000000000000000000000000000000000000000081565b6101376101da3660046108e7565b610493565b3480156101ea575f5ffd5b506100b07f000000000000000000000000000000000000000000000000000000000000000081565b3373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016146102c4576040517f771a23d300000000000000000000000000000000000000000000000000000000815233600482015273ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001660248201526044015b60405180910390fd5b5f5b81811015610352575f5f5f8585858181106102e3576102e36109b3565b90506020020160208101906102f89190610854565b73ffffffffffffffffffffffffffffffffffffffff16815260208101919091526040015f2080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00169115159190911790556001016102c6565b505050565b3373ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001614610404576040517f771a23d300000000000000000000000000000000000000000000000000000000815233600482015273ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001660248201526044016102bb565b5f5b818110156103525760015f5f858585818110610424576104246109b3565b90506020020160208101906104399190610854565b73ffffffffffffffffffffffffffffffffffffffff16815260208101919091526040015f2080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016911515919091179055600101610406565b3473ffffffffffffffffffffffffffffffffffffffff8416156104ff576104ba8382610a0d565b60405190915073ffffffffffffffffffffffffffffffffffffffff85169084156108fc029085905f818181858888f193505050501580156104fd573d5f5f3e3d5ffd5b505b335f9081526020819052604090205460ff166105fd577f00000000000000000000000000000000000000000000000000000000000000008114610597576040517f5755f3b6000000000000000000000000000000000000000000000000000000008152600481018290527f000000000000000000000000000000000000000000000000000000000000000060248201526044016102bb565b60405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169082156108fc029083905f818181858888f193505050501580156105f7573d5f5f3e3d5ffd5b50610672565b335f90815260208190526040902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001690558015610672576040517f5755f3b6000000000000000000000000000000000000000000000000000000008152600481018290525f60248201526044016102bb565b610680338989858a8a61068a565b5050505050505050565b5f61069786868585610720565b90508373ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff168873ffffffffffffffffffffffffffffffffffffffff167f6b460f6f5497bb72eeec65f6df538e6388b2e74b8fc03e7d318653a663e737828460405161070f91815260200190565b60405180910390a450505050505050565b5f8061072e83850185610a26565b50905061076f6bffffffffffffffffffffffff86167fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606084901b16610a5d565b6040517f94d008ef00000000000000000000000000000000000000000000000000000000815290925073ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016906394d008ef906107ea908990869089908990600401610a70565b5f604051808303815f87803b158015610801575f5ffd5b505af1158015610813573d5f5f3e3d5ffd5b5050505050949350505050565b73ffffffffffffffffffffffffffffffffffffffff81168114610841575f5ffd5b50565b803561084f81610820565b919050565b5f60208284031215610864575f5ffd5b813561086f81610820565b9392505050565b5f5f60208385031215610887575f5ffd5b823567ffffffffffffffff81111561089d575f5ffd5b8301601f810185136108ad575f5ffd5b803567ffffffffffffffff8111156108c3575f5ffd5b8560208260051b84010111156108d7575f5ffd5b6020919091019590945092505050565b5f5f5f5f5f5f5f60c0888a0312156108fd575f5ffd5b873561090881610820565b965060208801356bffffffffffffffffffffffff81168114610928575f5ffd5b9550604088013567ffffffffffffffff811115610943575f5ffd5b8801601f81018a13610953575f5ffd5b803567ffffffffffffffff811115610969575f5ffd5b8a602082840101111561097a575f5ffd5b6020919091019550935061099060608901610844565b9250608088013591506109a560a08901610844565b905092959891949750929550565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b81810381811115610a2057610a206109e0565b92915050565b5f5f60408385031215610a37575f5ffd5b8235610a4281610820565b91506020830135610a5281610820565b809150509250929050565b80820180821115610a2057610a206109e0565b73ffffffffffffffffffffffffffffffffffffffff8516815283602082015260606040820152816060820152818360808301375f818301608090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0160101939250505056fea26469706673582212205f56712a0a7245b596265d78bd41ad5f63272880d7a265fb5dbe735ef427a57f64736f6c634300081c0033",
  "deployedBytecode": "0x608060405260043610610079575f3560e01c80636bc55ab81161004c5780636bc55ab8146101585780637baa320b14610199578063c3b1328d146101cc578063e2bf56f3146101df575f5ffd5b80630d9019e11461007d578063277af731146100da5780633ba21e7214610118578063582dc0ba14610139575b5f5ffd5b348015610088575f5ffd5b506100b07f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b3480156100e5575f5ffd5b506101086100f4366004610854565b5f6020819052908152604090205460ff1681565b60405190151581526020016100d1565b348015610123575f5ffd5b50610137610132366004610876565b610212565b005b348015610144575f5ffd5b50610137610153366004610876565b610357565b348015610163575f5ffd5b5061018b7f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020016100d1565b3480156101a4575f5ffd5b506100b07f000000000000000000000000000000000000000000000000000000000000000081565b6101376101da3660046108e7565b610493565b3480156101ea575f5ffd5b506100b07f000000000000000000000000000000000000000000000000000000000000000081565b3373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016146102c4576040517f771a23d300000000000000000000000000000000000000000000000000000000815233600482015273ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001660248201526044015b60405180910390fd5b5f5b81811015610352575f5f5f8585858181106102e3576102e36109b3565b90506020020160208101906102f89190610854565b73ffffffffffffffffffffffffffffffffffffffff16815260208101919091526040015f2080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00169115159190911790556001016102c6565b505050565b3373ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001614610404576040517f771a23d300000000000000000000000000000000000000000000000000000000815233600482015273ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001660248201526044016102bb565b5f5b818110156103525760015f5f858585818110610424576104246109b3565b90506020020160208101906104399190610854565b73ffffffffffffffffffffffffffffffffffffffff16815260208101919091526040015f2080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016911515919091179055600101610406565b3473ffffffffffffffffffffffffffffffffffffffff8416156104ff576104ba8382610a0d565b60405190915073ffffffffffffffffffffffffffffffffffffffff85169084156108fc029085905f818181858888f193505050501580156104fd573d5f5f3e3d5ffd5b505b335f9081526020819052604090205460ff166105fd577f00000000000000000000000000000000000000000000000000000000000000008114610597576040517f5755f3b6000000000000000000000000000000000000000000000000000000008152600481018290527f000000000000000000000000000000000000000000000000000000000000000060248201526044016102bb565b60405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169082156108fc029083905f818181858888f193505050501580156105f7573d5f5f3e3d5ffd5b50610672565b335f90815260208190526040902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001690558015610672576040517f5755f3b6000000000000000000000000000000000000000000000000000000008152600481018290525f60248201526044016102bb565b610680338989858a8a61068a565b5050505050505050565b5f61069786868585610720565b90508373ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff168873ffffffffffffffffffffffffffffffffffffffff167f6b460f6f5497bb72eeec65f6df538e6388b2e74b8fc03e7d318653a663e737828460405161070f91815260200190565b60405180910390a450505050505050565b5f8061072e83850185610a26565b50905061076f6bffffffffffffffffffffffff86167fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606084901b16610a5d565b6040517f94d008ef00000000000000000000000000000000000000000000000000000000815290925073ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016906394d008ef906107ea908990869089908990600401610a70565b5f604051808303815f87803b158015610801575f5ffd5b505af1158015610813573d5f5f3e3d5ffd5b5050505050949350505050565b73ffffffffffffffffffffffffffffffffffffffff81168114610841575f5ffd5b50565b803561084f81610820565b919050565b5f60208284031215610864575f5ffd5b813561086f81610820565b9392505050565b5f5f60208385031215610887575f5ffd5b823567ffffffffffffffff81111561089d575f5ffd5b8301601f810185136108ad575f5ffd5b803567ffffffffffffffff8111156108c3575f5ffd5b8560208260051b84010111156108d7575f5ffd5b6020919091019590945092505050565b5f5f5f5f5f5f5f60c0888a0312156108fd575f5ffd5b873561090881610820565b965060208801356bffffffffffffffffffffffff81168114610928575f5ffd5b9550604088013567ffffffffffffffff811115610943575f5ffd5b8801601f81018a13610953575f5ffd5b803567ffffffffffffffff811115610969575f5ffd5b8a602082840101111561097a575f5ffd5b6020919091019550935061099060608901610844565b9250608088013591506109a560a08901610844565b905092959891949750929550565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b81810381811115610a2057610a206109e0565b92915050565b5f5f60408385031215610a37575f5ffd5b8235610a4281610820565b91506020830135610a5281610820565b809150509250929050565b80820180821115610a2057610a206109e0565b73ffffffffffffffffffffffffffffffffffffffff8516815283602082015260606040820152816060820152818360808301375f818301608090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0160101939250505056fea26469706673582212205f56712a0a7245b596265d78bd41ad5f63272880d7a265fb5dbe735ef427a57f64736f6c634300081c0033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "evm": {
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "567600",
        "executionCost": "infinite",
        "totalCost": "infinite"
      },
      "external": {
        "FREE_MAP_ADMIN()": "infinite",
        "ITEMS()": "infinite",
        "PAYMENT_AMOUNT()": "infinite",
        "RECIPIENT()": "infinite",
        "addToFreeMap(address[])": "infinite",
        "freemap(address)": "2536",
        "purchase(address,uint96,bytes,address,uint256,address)": "infinite",
        "removeFromFreeMap(address[])": "infinite"
      },
      "internal": {
        "_executeMint(address,uint96,bytes calldata)": "infinite"
      }
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract Avatars\",\"name\":\"items\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"paymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"freeMapAdmin\",\"type\":\"address\"}],\"internalType\":\"struct SaleViaNativePayment.Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ExpectNativeToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"FailedToTransferNativeToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expected\",\"type\":\"address\"}],\"name\":\"NotFreeMapAdmin\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"}],\"name\":\"WrongPaymentAmount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FREE_MAP_ADMIN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ITEMS\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAYMENT_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RECIPIENT\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"addToFreeMap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"freemap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"subID\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address payable\",\"name\":\"extraNativeTokenRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"extraNativeTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"purchase\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"removeFromFreeMap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"project/src/avatars/AvatarsSale.sol\":\"AvatarsSale\"},\"evmVersion\":\"prague\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":999999},\"remappings\":[\"project/:@rocketh/proxy/=npm/@rocketh/proxy@0.14.6/\",\"project/:solidity-kit/=npm/solidity-kit@0.5.7/\"]},\"sources\":{\"npm/@rocketh/proxy@0.14.6/solc_0_8/ERC1967/Proxied.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract Proxied {\\n    /// @notice to be used by initialisation / postUpgrade function so that only the proxy's admin can execute them\\n    /// It also allows these functions to be called inside a contructor\\n    /// even if the contract is meant to be used without proxy\\n    modifier proxied() {\\n        address proxyAdminAddress = _proxyAdmin();\\n        // With hardhat-deploy proxies\\n        // the proxyAdminAddress is zero only for the implementation contract\\n        // if the implementation contract want to be used as a standalone/immutable contract\\n        // it simply has to execute the `proxied` function\\n        // This ensure the proxyAdminAddress is never zero post deployment\\n        // And allow you to keep the same code for both proxied contract and immutable contract\\n        if (proxyAdminAddress == address(0)) {\\n            // ensure can not be called twice when used outside of proxy : no admin\\n            // solhint-disable-next-line security/no-inline-assembly\\n            assembly {\\n                sstore(\\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n            }\\n        } else {\\n            require(msg.sender == proxyAdminAddress);\\n        }\\n        _;\\n    }\\n\\n    modifier onlyProxyAdmin() {\\n        require(msg.sender == _proxyAdmin(), \\\"NOT_AUTHORIZED\\\");\\n        _;\\n    }\\n\\n    function _proxyAdmin() internal view returns (address ownerAddress) {\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            ownerAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaaceeafeeaf0d200ca3942d8bf14c1c4f787a77f79cc87c08bb668e65acdee29\",\"license\":\"MIT\"},\"npm/solidity-kit@0.5.7/solc_0_8/ERC165/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x0bbdb7cf3d2c6acf95398c0ef54cb0e6ae8a3e6ce6f18fafeb0aa55cb74fb8fd\",\"license\":\"MIT\"},\"npm/solidity-kit@0.5.7/solc_0_8/ERC20/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./UsingERC20Events.sol\\\";\\n\\ninterface IERC20 is UsingERC20Events {\\n    /// @notice Returns the total token supply.\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Returns the number of decimals the token uses.\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Returns the symbol of the token.\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Returns the name of the token.\\n    function name() external view returns (string memory);\\n\\n    /// @notice Returns the account balance of another account with address `owner`.\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    /// @notice Transfers `amount` of tokens to address `to`.\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Returns the amount which `spender` is still allowed to withdraw from `owner`.\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /// @notice Allows `spender` to withdraw from your account multiple times, up to `amount`.\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /// @notice Transfers `amount` tokens from address `from` to address `to`.\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x3a6bcd5cf1d9e50fbe405f4c6c9c868e97ce2a84ae99fd7c1fb2d916c4d5debd\",\"license\":\"MIT\"},\"npm/solidity-kit@0.5.7/solc_0_8/ERC20/interfaces/UsingERC20Events.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface UsingERC20Events {\\n    /// @notice trigger when tokens are transferred, including zero value transfers.\\n    /// @param from the account the tokens are sent from\\n    /// @param to the account the tokens are sent to\\n    /// @param value number of tokens sent\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /// @notice trigger on approval amount being set.\\n    ///   Note that Transfer events need to be considered to compute the current allowance.\\n    /// @param owner the account approving the `spender`\\n    /// @param spender the account allowed to spend\\n    /// @param value the amount granted\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x15eaa1de7fe9e02ba9e83f262b2b7f33a4bfe0f5a3ae2be4d616b6c4dce1c6fa\",\"license\":\"MIT\"},\"npm/solidity-kit@0.5.7/solc_0_8/ERC721/implementations/BasicERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IERC721Receiver.sol\\\";\\nimport \\\"../interfaces/IERC721.sol\\\";\\nimport \\\"../interfaces/UsingERC721Errors.sol\\\";\\nimport \\\"../interfaces/IERC721WithBlocknumber.sol\\\";\\nimport \\\"./ImplementingERC721Internal.sol\\\";\\nimport \\\"../../utils/UsingGenericErrors.sol\\\";\\n\\nimport \\\"../../openzeppelin/contracts/utils/Address.sol\\\";\\n\\nabstract contract BasicERC721 is IERC721, IERC721WithBlocknumber, ImplementingERC721Internal, UsingERC721Errors {\\n    using Openzeppelin_Address for address;\\n\\n    bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\\n\\n    uint256 internal constant OPERATOR_FLAG = 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n    mapping(uint256 => uint256) internal _owners;\\n    mapping(address => uint256) internal _balances;\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n    mapping(uint256 => address) internal _operators;\\n\\n    /// @inheritdoc IERC721\\n    function approve(address operator, uint256 tokenID) external override {\\n        (address owner, uint256 nonce) = _ownerAndNonceOf(tokenID);\\n        if (owner == address(0)) {\\n            revert NonExistentToken(tokenID);\\n        }\\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) {\\n            revert UsingGenericErrors.NotAuthorized();\\n        }\\n        _approveFor(owner, nonce, operator, tokenID);\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function transferFrom(address from, address to, uint256 tokenID) external override {\\n        (address owner, uint256 nonce, bool operatorEnabled) = _ownerNonceAndOperatorEnabledOf(tokenID);\\n        if (owner == address(0)) {\\n            revert NonExistentToken(tokenID);\\n        }\\n        if (from != owner) {\\n            revert NotOwner(from, owner);\\n        }\\n        if (to == address(0) || to == address(this)) {\\n            revert InvalidAddress(to);\\n        }\\n        if (msg.sender != from) {\\n            if (!(operatorEnabled && _operators[tokenID] == msg.sender) && !isApprovedForAll(from, msg.sender)) {\\n                revert UsingGenericErrors.NotAuthorized();\\n            }\\n        }\\n        _transferFrom(from, to, tokenID, (nonce >> 24) != 0);\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function safeTransferFrom(address from, address to, uint256 tokenID) external override {\\n        safeTransferFrom(from, to, tokenID, \\\"\\\");\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function setApprovalForAll(address operator, bool approved) external override {\\n        _setApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function balanceOf(address owner) public view virtual override returns (uint256 balance) {\\n        if (owner == address(0)) {\\n            revert InvalidAddress(owner);\\n        }\\n        balance = _balances[owner];\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function ownerOf(uint256 tokenID) external view override returns (address owner) {\\n        owner = _ownerOf(tokenID);\\n        if (owner == address(0)) {\\n            revert NonExistentToken(tokenID);\\n        }\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function getApproved(uint256 tokenID) external view override returns (address operator) {\\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(tokenID);\\n        if (owner == address(0)) {\\n            revert NonExistentToken(tokenID);\\n        }\\n        if (operatorEnabled) {\\n            return _operators[tokenID];\\n        } else {\\n            return address(0);\\n        }\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool isOperator) {\\n        return _operatorsForAll[owner][operator];\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function safeTransferFrom(address from, address to, uint256 tokenID, bytes memory data) public override {\\n        (address owner, uint256 nonce, bool operatorEnabled) = _ownerNonceAndOperatorEnabledOf(tokenID);\\n        if (owner == address(0)) {\\n            revert NonExistentToken(tokenID);\\n        }\\n        if (owner != from) {\\n            revert NotOwner(from, owner);\\n        }\\n\\n        if (to == address(0) || to == address(this)) {\\n            revert InvalidAddress(to);\\n        }\\n\\n        if (msg.sender != from) {\\n            if (!(operatorEnabled && _operators[tokenID] == msg.sender) && !isApprovedForAll(from, msg.sender)) {\\n                revert UsingGenericErrors.NotAuthorized();\\n            }\\n        }\\n        _safeTransferFrom(from, to, tokenID, (nonce >> 24) != 0, data);\\n    }\\n\\n    /// @inheritdoc IERC165\\n    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\\n        /// 0x01ffc9a7 is ERC165.\\n        /// 0x80ac58cd is ERC721\\n        /// 0x5b5e139f is for ERC721 metadata\\n        return interfaceID == 0x01ffc9a7 || interfaceID == 0x80ac58cd || interfaceID == 0x5b5e139f;\\n    }\\n\\n    /// @inheritdoc IERC721WithBlocknumber\\n    function ownerAndLastTransferBlockNumberOf(\\n        uint256 tokenID\\n    ) external view override returns (address owner, uint256 blockNumber) {\\n        (address currentOwner, uint256 nonce) = _ownerAndNonceOf(tokenID);\\n        owner = currentOwner;\\n        blockNumber = (nonce >> 24);\\n    }\\n\\n    /// @inheritdoc IERC721WithBlocknumber\\n    function ownerAndLastTransferBlockNumberList(\\n        uint256[] calldata tokenIDs\\n    ) external view virtual returns (OwnerData[] memory ownersData) {\\n        ownersData = new OwnerData[](tokenIDs.length);\\n        for (uint256 i = 0; i < tokenIDs.length; i++) {\\n            uint256 data = _owners[tokenIDs[i]];\\n            ownersData[i].owner = address(uint160(data));\\n            ownersData[i].lastTransferBlockNumber = (data >> 184) & 0xFFFFFFFFFFFFFFFF;\\n        }\\n    }\\n\\n    // ------------------------------------------------------------------------------------------------------------------\\n    // INTERNALS\\n    // ------------------------------------------------------------------------------------------------------------------\\n\\n    function _burn(uint256 tokenID) internal virtual {\\n        address owner = _ownerOf(tokenID);\\n        if (owner == address(0)) {\\n            revert NonExistentToken(tokenID);\\n        }\\n        _balances[owner]--;\\n        _owners[tokenID] = (block.number << 184);\\n        emit Transfer(owner, address(0), tokenID);\\n    }\\n\\n    function _safeMint(address to, uint256 tokenID, bool remintingAllowed, bytes memory data) internal {\\n        (address owner, uint256 nonce, ) = _ownerNonceAndOperatorEnabledOf(tokenID);\\n        if (owner != address(0)) {\\n            revert TokenAlreadyExists(tokenID);\\n        }\\n        if (!remintingAllowed && nonce != 0) {\\n            revert TokenCannotBeReminted(tokenID);\\n        }\\n        _safeTransferFrom(address(0), to, tokenID, false, data);\\n    }\\n\\n    function _safeTransferFrom(address from, address to, uint256 tokenID, bool registered, bytes memory data) internal {\\n        _transferFrom(from, to, tokenID, registered);\\n        if (to.isContract()) {\\n            if (!_checkOnERC721Received(msg.sender, from, to, tokenID, data)) {\\n                revert TransferRejected();\\n            }\\n        }\\n    }\\n\\n    function _transferFrom(address from, address to, uint256 tokenID, bool registered) internal virtual {\\n        unchecked {\\n            _balances[to]++;\\n            if (registered) {\\n                _balances[from]--;\\n            }\\n        }\\n\\n        // We encode the blockNumber in the token nonce. We can then use it for count voting.\\n        _owners[tokenID] = (block.number << 184) | uint256(uint160(to));\\n        emit Transfer(from, to, tokenID);\\n    }\\n\\n    /// @dev See approve.\\n    function _approveFor(address owner, uint256 nonce, address operator, uint256 tokenID) internal override {\\n        uint256 blockNumber = nonce >> 24;\\n        uint256 newNonce = nonce + 1;\\n        if (newNonce >> 24 != blockNumber) {\\n            revert NonceOverflow();\\n        }\\n        if (operator == address(0)) {\\n            _owners[tokenID] = (newNonce << 160) | uint256(uint160(owner));\\n        } else {\\n            _owners[tokenID] = OPERATOR_FLAG | ((newNonce << 160) | uint256(uint160(owner)));\\n            _operators[tokenID] = operator;\\n        }\\n        emit Approval(owner, operator, tokenID);\\n    }\\n\\n    /// @dev See setApprovalForAll.\\n    function _setApprovalForAll(address sender, address operator, bool approved) internal override {\\n        _operatorsForAll[sender][operator] = approved;\\n\\n        emit ApprovalForAll(sender, operator, approved);\\n    }\\n\\n    /// @dev Check if receiving contract accepts erc721 transfers.\\n    /// @param operator The address of the operator.\\n    /// @param from The from address, may be different from msg.sender.\\n    /// @param to The adddress we want to transfer to.\\n    /// @param tokenID The id of the token we would like to transfer.\\n    /// @param data Any additional data to send with the transfer.\\n    /// @return Whether the expected value of 0x150b7a02 is returned.\\n    function _checkOnERC721Received(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 tokenID,\\n        bytes memory data\\n    ) internal returns (bool) {\\n        bytes4 retval = IERC721Receiver(to).onERC721Received(operator, from, tokenID, data);\\n        return (retval == ERC721_RECEIVED);\\n    }\\n\\n    /// @dev Get the owner of a token.\\n    /// @param tokenID The token to query.\\n    function _ownerOf(uint256 tokenID) internal view virtual returns (address owner) {\\n        return address(uint160(_owners[tokenID]));\\n    }\\n\\n    /// @dev Get the owner and operatorEnabled status of a token.\\n    /// @param tokenID The token to query.\\n    /// @return owner The owner of the token.\\n    /// @return operatorEnabled Whether or not operators are enabled for this token.\\n    function _ownerAndOperatorEnabledOf(\\n        uint256 tokenID\\n    ) internal view virtual returns (address owner, bool operatorEnabled) {\\n        uint256 data = _owners[tokenID];\\n        owner = address(uint160(data));\\n        operatorEnabled = (data & OPERATOR_FLAG) == OPERATOR_FLAG;\\n    }\\n\\n    /// @dev Get the owner and the permit nonce of a token.\\n    /// @param tokenID The token to query.\\n    /// @return owner The owner of the token.\\n    /// @return nonce the nonce for permit (also incluse the blocknumer in the 64 higer bits (88 bits in total))\\n    function _ownerAndNonceOf(uint256 tokenID) internal view virtual override returns (address owner, uint256 nonce) {\\n        uint256 data = _owners[tokenID];\\n        owner = address(uint160(data));\\n        nonce = (data >> 160) & 0xFFFFFFFFFFFFFFFFFFFFFF;\\n    }\\n\\n    // @dev Get the owner, the permit nonce of a token and operatorEnabled status of a token.\\n    /// @param tokenID The token to query.\\n    /// @return owner The owner of the token.\\n    /// @return nonce the nonce for permit (also incluse the blocknumer in the 64 higer bits (88 bits in total))\\n    /// @return operatorEnabled Whether or not operators are enabled for this token.\\n    function _ownerNonceAndOperatorEnabledOf(\\n        uint256 tokenID\\n    ) internal view virtual returns (address owner, uint256 nonce, bool operatorEnabled) {\\n        uint256 data = _owners[tokenID];\\n        owner = address(uint160(data));\\n        operatorEnabled = (data & OPERATOR_FLAG) == OPERATOR_FLAG;\\n        nonce = (data >> 160) & 0xFFFFFFFFFFFFFFFFFFFFFF;\\n    }\\n}\\n\",\"keccak256\":\"0xd8aecab1e3976d0edc0e7fe1cb8778624c4a3d1d8fec0cdc2c33ba6e22a199cf\",\"license\":\"MIT\"},\"npm/solidity-kit@0.5.7/solc_0_8/ERC721/implementations/EnumerableERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IERC721Enumerable.sol\\\";\\nimport \\\"./BasicERC721.sol\\\";\\n\\ncontract EnumerableERC721 is IERC721Enumerable, BasicERC721 {\\n    error ERC721OutOfBoundsIndex(address owner, uint256 index);\\n\\n    mapping(address owner => mapping(uint256 index => uint256)) private _ownedTokens;\\n    mapping(uint256 tokenId => uint256) private _ownedTokensIndex;\\n\\n    uint256[] private _allTokens;\\n    mapping(uint256 tokenId => uint256) private _allTokensIndex;\\n\\n    // ------------------------------------------------------------------------\\n    // IERC721Enumerable\\n    // ------------------------------------------------------------------------\\n    /// @inheritdoc IERC721Enumerable\\n    function totalSupply() public view returns (uint256) {\\n        return _allTokens.length;\\n    }\\n\\n    /// @inheritdoc IERC721Enumerable\\n    function tokenByIndex(uint256 index) external view returns (uint256) {\\n        if (index >= totalSupply()) {\\n            revert ERC721OutOfBoundsIndex(address(0), index);\\n        }\\n        return _allTokens[index];\\n    }\\n\\n    /// @inheritdoc IERC721Enumerable\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256) {\\n        if (index >= balanceOf(owner)) {\\n            revert ERC721OutOfBoundsIndex(owner, index);\\n        }\\n        return _ownedTokens[owner][index];\\n    }\\n\\n    /// @inheritdoc IERC165\\n    function supportsInterface(bytes4 interfaceId) public view override(IERC165, BasicERC721) returns (bool) {\\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n    // ------------------------------------------------------------------------\\n\\n    // ------------------------------------------------------------------------\\n    // EXTRA FUNCTIONALITY\\n    // ------------------------------------------------------------------------\\n    /// @notice returns the list of token ids owned by the account specified\\n    /// @dev Note that when calling multiple time, to fetch more than limit\\n    ///  you need to make sure to specify the block to target to ensure\\n    ///  consistency as token order can change\\n    /// @param owner An address where we are interested in NFTs owned by them\\n    /// @param index A counter less than `balanceOf(_owner)`\\n    /// @param limit the max number of token ids to return\\n    /// @return tokenIDs the list of ids\\n    /// @return more a boolean indicating whether there is more to fetch\\n    function tokensOfOwner(\\n        address owner,\\n        uint256 index,\\n        uint256 limit\\n    ) external view returns (uint256[] memory tokenIDs, bool more) {\\n        uint256 total = balanceOf(owner);\\n        if (index >= total) {\\n            return (new uint256[](0), false);\\n        }\\n        uint256 max = total - index;\\n        uint256 actualLimit = limit > max ? max : limit;\\n\\n        uint256[] memory list = new uint256[](actualLimit);\\n\\n        for (uint256 i = 0; i < actualLimit; i++) {\\n            list[i] = _ownedTokens[owner][index + i];\\n        }\\n\\n        return (list, actualLimit != limit);\\n    }\\n    // ------------------------------------------------------------------------\\n\\n    // ------------------------------------------------------------------------\\n    // OVERRIDES\\n    // ------------------------------------------------------------------------\\n\\n    function _burn(uint256 tokenID) internal override {\\n        address owner = _ownerOf(tokenID);\\n        super._burn(tokenID);\\n        _removeTokenFromOwnerEnumeration(owner, tokenID);\\n        _removeTokenFromAllTokensEnumeration(tokenID);\\n    }\\n\\n    function _transferFrom(address from, address to, uint256 tokenID, bool registered) internal override {\\n        super._transferFrom(from, to, tokenID, registered);\\n\\n        if (from == address(0)) {\\n            _addTokenToAllTokensEnumeration(tokenID);\\n        } else if (from != to) {\\n            _removeTokenFromOwnerEnumeration(from, tokenID);\\n        }\\n        if (to == address(0)) {\\n            _removeTokenFromAllTokensEnumeration(tokenID);\\n        } else if (from != to) {\\n            _addTokenToOwnerEnumeration(to, tokenID);\\n        }\\n    }\\n\\n    // ------------------------------------------------------------------------\\n\\n    // ------------------------------------------------------------------------\\n    // UTILITIES (from openzeppelin)\\n    // ------------------------------------------------------------------------\\n\\n    /**\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n        uint256 length = balanceOf(to) - 1;\\n        _ownedTokens[to][length] = tokenId;\\n        _ownedTokensIndex[tokenId] = length;\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\n        _allTokensIndex[tokenId] = _allTokens.length;\\n        _allTokens.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = balanceOf(from);\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n\\n        mapping(uint256 index => uint256) storage _ownedTokensByOwner = _ownedTokens[from];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = _ownedTokensByOwner[lastTokenIndex];\\n\\n            _ownedTokensByOwner[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n        }\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _ownedTokensIndex[tokenId];\\n        delete _ownedTokensByOwner[lastTokenIndex];\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = _allTokens.length - 1;\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\n\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _allTokensIndex[tokenId];\\n        _allTokens.pop();\\n    }\\n}\\n\",\"keccak256\":\"0xb85f187d1009797978dad0842247cf2085a17293a123cdca765a6190aca01638\",\"license\":\"MIT\"},\"npm/solidity-kit@0.5.7/solc_0_8/ERC721/implementations/ImplementingERC721Internal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract ImplementingERC721Internal {\\n    function _ownerAndNonceOf(uint256 tokenID) internal view virtual returns (address owner, uint256 nonce);\\n\\n    function _approveFor(\\n        address owner,\\n        uint256 nonce,\\n        address operator,\\n        uint256 tokenID\\n    ) internal virtual;\\n\\n    function _setApprovalForAll(\\n        address sender,\\n        address operator,\\n        bool approved\\n    ) internal virtual;\\n}\\n\",\"keccak256\":\"0xa8a6ed1a764da2589bd932b67174805ef0c47120d27fa4defc17a2368757efbe\",\"license\":\"MIT\"},\"npm/solidity-kit@0.5.7/solc_0_8/ERC721/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../ERC165/interfaces/IERC165.sol\\\";\\nimport \\\"./UsingERC721Events.sol\\\";\\n\\ninterface IERC721Supply {\\n    /// @notice return the total number of token in existence\\n    function totalSupply() external view returns (uint256);\\n}\\n\\ninterface IERC721 is IERC165, UsingERC721Events {\\n    /// @notice Get the number of tokens owned by an address.\\n    /// @param owner The address to look for.\\n    /// @return balance The number of tokens owned by the address.\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /// @notice Get the owner of a token.\\n    /// @param tokenID The id of the token.\\n    /// @return owner The address of the token owner.\\n    function ownerOf(uint256 tokenID) external view returns (address owner);\\n\\n    /// @notice Transfer a token between 2 addresses letting the receiver knows of the transfer.\\n    /// @param from The sender of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    /// @param data Additional data.\\n    function safeTransferFrom(address from, address to, uint256 tokenID, bytes calldata data) external;\\n\\n    /// @notice Transfer a token between 2 addresses letting the receiver know of the transfer.\\n    /// @param from The send of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    function safeTransferFrom(address from, address to, uint256 tokenID) external;\\n\\n    /// @notice Transfer a token between 2 addresses.\\n    /// @param from The sender of the token.\\n    /// @param to The recipient of the token.\\n    /// @param tokenID The id of the token.\\n    function transferFrom(address from, address to, uint256 tokenID) external;\\n\\n    /// @notice Approve an operator to transfer a specific token on the senders behalf.\\n    /// @param operator The address receiving the approval.\\n    /// @param tokenID The id of the token.\\n    function approve(address operator, uint256 tokenID) external;\\n\\n    /// @notice Set the approval for an operator to manage all the tokens of the sender.\\n    /// @param operator The address receiving the approval.\\n    /// @param approved The determination of the approval.\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /// @notice Get the approved operator for a specific token.\\n    /// @param tokenID The id of the token.\\n    /// @return operator The address of the operator.\\n    function getApproved(uint256 tokenID) external view returns (address operator);\\n\\n    /// @notice Check if the sender approved the operator to transfer any of its tokens.\\n    /// @param owner The address of the owner.\\n    /// @param operator The address of the operator.\\n    /// @return isOperator The status of the approval.\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xa2a5afc2f4e761179de9c718ee807e2d682ed4ae39884906ac333c20282a95d1\",\"license\":\"MIT\"},\"npm/solidity-kit@0.5.7/solc_0_8/ERC721/interfaces/IERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\ninterface IERC721Enumerable is IERC721 {\\n    /// @notice Count NFTs tracked by this contract\\n    /// @return A count of valid NFTs tracked by this contract, where each one of\\n    ///  them has an assigned and queryable owner not equal to the zero address\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Enumerate valid NFTs\\n    /// @dev Throws if `_index` >= `totalSupply()`.\\n    /// @param _index A counter less than `totalSupply()`\\n    /// @return The token identifier for the `_index`th NFT,\\n    ///  (sort order not specified)\\n    function tokenByIndex(uint256 _index) external view returns (uint256);\\n\\n    /// @notice Enumerate NFTs assigned to an owner\\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\\n    ///  `_owner` is the zero address, representing invalid NFTs.\\n    /// @param _owner An address where we are interested in NFTs owned by them\\n    /// @param _index A counter less than `balanceOf(_owner)`\\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\\n    ///   (sort order not specified)\\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x2e4940c9163260463390da19c62b42ea3debde71faab9b6ba712d4e621df55de\",\"license\":\"MIT\"},\"npm/solidity-kit@0.5.7/solc_0_8/ERC721/interfaces/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC721Receiver {\\n    /// @notice Handle the receipt of an NFT\\n    /// @dev The ERC721 smart contract calls this function on the recipient\\n    ///  after a `transfer`. This function MAY throw to revert and reject the\\n    ///  transfer. Return of other than the magic value MUST result in the\\n    ///  transaction being reverted.\\n    ///  Note: the contract address is always the message sender.\\n    /// @param operator The address which called `safeTransferFrom` function\\n    /// @param from The address which previously owned the token\\n    /// @param tokenID The NFT identifier which is being transferred\\n    /// @param data Additional data with no specified format\\n    /// @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    ///  unless throwing\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenID,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x47e1a42d5906cbc70c15f0352836dc7922d857632075c858f64e6286669a5e2e\",\"license\":\"MIT\"},\"npm/solidity-kit@0.5.7/solc_0_8/ERC721/interfaces/IERC721WithBlocknumber.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC721WithBlocknumber {\\n    /// @notice Get the owner of a token and the blockNumber of the last transfer, useful to voting mechanism.\\n    /// @param tokenID The id of the token.\\n    /// @return owner The address of the token owner.\\n    /// @return blockNumber The blocknumber at which the last transfer of that id happened.\\n    function ownerAndLastTransferBlockNumberOf(uint256 tokenID)\\n        external\\n        view\\n        returns (address owner, uint256 blockNumber);\\n\\n    struct OwnerData {\\n        address owner;\\n        uint256 lastTransferBlockNumber;\\n    }\\n\\n    /// @notice Get the list of owner of a token and the blockNumber of its last transfer, useful to voting mechanism.\\n    /// @param tokenIDs The list of token ids to check.\\n    /// @return ownersData The list of (owner, lastTransferBlockNumber) for each ids given as input.\\n    function ownerAndLastTransferBlockNumberList(uint256[] calldata tokenIDs)\\n        external\\n        view\\n        returns (OwnerData[] memory ownersData);\\n}\\n\",\"keccak256\":\"0x2461ec24c55a1b6c13d451e52ad7600bc2da469996041700a3775efbcde7042b\",\"license\":\"MIT\"},\"npm/solidity-kit@0.5.7/solc_0_8/ERC721/interfaces/UsingERC721Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface UsingERC721Errors {\\n    /// @notice The token does not exist\\n    /// @param tokenID id of the expected token\\n    error NonExistentToken(uint256 tokenID);\\n\\n    /// @notice The token already exists\\n    /// @param tokenID id of the expected token\\n    error TokenAlreadyExists(uint256 tokenID);\\n\\n    /// @notice The token was minted prior and cannot be reminted\\n    /// @param tokenID id of the expected token\\n    error TokenCannotBeReminted(uint256 tokenID);\\n\\n    /// @notice The address from which the token is sent is not the current owner\\n    /// @param provided the address expected to be the current owner\\n    /// @param currentOwner the current owner\\n    error NotOwner(address provided, address currentOwner);\\n\\n    /// @notice An invalid address is specified (for example: zero address)\\n    /// @param addr invalid address\\n    error InvalidAddress(address addr);\\n\\n    /// @notice The Transfer was rejected by the destination\\n    error TransferRejected();\\n\\n    /// @notice The Nonce overflowed, make a transfer to self to allow new nonces.\\n    error NonceOverflow();\\n}\\n\",\"keccak256\":\"0x7cc8bcc3f380e6420a45287dec709615047383a151fcb537c407b8dd9a3e99a9\",\"license\":\"MIT\"},\"npm/solidity-kit@0.5.7/solc_0_8/ERC721/interfaces/UsingERC721Events.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface UsingERC721Events {\\n    /// @notice Triggered when a token is transferred\\n    /// @param from the account the token is sent from\\n    /// @param to the account the token is sent to\\n    /// @param tokenID id of the token being sent\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenID);\\n\\n    /// @notice Triggered when a token is approved to be sent by another account\\n    ///  Note tat the approval get reset when a Transfer event for that same token is emitted.\\n    /// @param owner current owner of the token\\n    /// @param approved account who can know transfer on the owner's behalf\\n    /// @param tokenID id of the token being approved\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenID);\\n\\n    /// @notice Triggered when an account approve or disaprove another to transfer on its behalf\\n    /// @param owner the account granting rights over all of its token\\n    /// @param operator account who can know transfer on the owner's behalf\\n    /// @param approved whether it is approved or not\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n}\\n\",\"keccak256\":\"0x1b0d4ae18443a686be830d3a6ce203d563fe2f42ac9cc3fdf722b702d18152a2\",\"license\":\"MIT\"},\"npm/solidity-kit@0.5.7/solc_0_8/openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Openzeppelin_Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x54a1b5eb6fdeb706049c5f570c398a49ea05f3da2d8e35f3ae344059d622350a\",\"license\":\"MIT\"},\"npm/solidity-kit@0.5.7/solc_0_8/utils/UsingGenericErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface UsingGenericErrors {\\n    /// @notice Not authorized to perform this operation\\n    error NotAuthorized();\\n\\n    /// @notice Token cannot be transfered\\n    error NonTransferable();\\n\\n    /// @notice function is not implemented\\n    error NotImplemented();\\n}\\n\",\"keccak256\":\"0x20c56b2d5fb3d35c86ba8325a342f4e7c21c8db3c5edf967f7ddd0c49f692e8f\",\"license\":\"MIT\"},\"project/src/avatars/Avatars.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"solidity-kit/solc_0_8/ERC721/implementations/EnumerableERC721.sol\\\";\\n\\ncontract Avatars is EnumerableERC721 {\\n    constructor() {}\\n\\n    function mint(address to, uint256 tokenID, bytes calldata data) external payable {\\n        _safeMint(to, tokenID, false, data);\\n    }\\n}\\n\",\"keccak256\":\"0x94ca280d2697b052acb0004d2c26ce11272e4b7e8f0e83152bdd003061268dfe\",\"license\":\"AGPL-3.0-or-later\"},\"project/src/avatars/AvatarsSale.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./SaleViaNativePayment.sol\\\";\\nimport \\\"./Avatars.sol\\\";\\n\\ncontract AvatarsSale is SaleViaNativePayment {\\n    constructor(Avatars items, Config memory config) SaleViaNativePayment(items, config) {}\\n\\n    function _executeMint(address to, uint96 subID, bytes calldata data) internal override returns (uint256 tokenID) {\\n        (address owner, ) = abi.decode(data, (address, address));\\n        tokenID = (uint256(uint160(owner)) << 96) + subID;\\n        Avatars(address(ITEMS)).mint(to, tokenID, data);\\n    }\\n}\\n\",\"keccak256\":\"0x393274d1d4d8586f60e7eb48c82486df5b2b05035e227a0c7d5699fef307e0e4\",\"license\":\"AGPL-3.0-or-later\"},\"project/src/avatars/SaleViaNativePayment.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@rocketh/proxy/solc_0_8/ERC1967/Proxied.sol\\\";\\n\\nimport \\\"solidity-kit/solc_0_8/ERC20/interfaces/IERC20.sol\\\";\\n\\nimport \\\"solidity-kit/solc_0_8/ERC721/interfaces/IERC721.sol\\\";\\n\\ninterface IERC20Permit {\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\\nabstract contract SaleViaNativePayment is Proxied {\\n    error ExpectNativeToken();\\n    error WrongPaymentAmount(uint256 amount, uint256 expected);\\n    error TransferFailed(IERC20 token, address from, address to, uint256 amount);\\n    error FailedToTransferNativeToken(address recipient);\\n    error NotFreeMapAdmin(address sender, address expected);\\n\\n    event Mint(address indexed sender, address indexed to, address indexed referrer, uint256 tokenID);\\n\\n    IERC721 public immutable ITEMS;\\n    uint256 public immutable PAYMENT_AMOUNT;\\n    address payable public immutable RECIPIENT;\\n    address public immutable FREE_MAP_ADMIN;\\n\\n    mapping(address => bool) public freemap;\\n\\n    struct Config {\\n        uint256 paymentAmount;\\n        address payable recipient;\\n        address freeMapAdmin;\\n    }\\n\\n    constructor(IERC721 items, Config memory config) {\\n        ITEMS = items;\\n        PAYMENT_AMOUNT = config.paymentAmount;\\n        RECIPIENT = config.recipient;\\n        FREE_MAP_ADMIN = config.freeMapAdmin;\\n    }\\n\\n    // function purchaseViaTokenWithPermit(\\n    //     address payable to,\\n    //     bytes calldata data,\\n    //     uint256 amount,\\n    //     uint256 deadline,\\n    //     uint8 v,\\n    //     bytes32 r,\\n    //     bytes32 s,\\n    //     address referrer\\n    // ) external {\\n    //     if (!freemap[msg.sender]) {\\n    //         // Commands:\\n    //         // 0x0B: WRAP_ETH (convert ETH to WETH)\\n    //         // 0x01: V3_SWAP_EXACT_OUT (perform exact output swap)\\n    //         // 0x0C: UNWRAP_WETH (convert any remaining WETH back to ETH)\\n    //         bytes memory commands = hex\\\"0B010C\\\";\\n\\n    //         // Inputs for the commands\\n    //         bytes[] memory inputs = new bytes[](3);\\n\\n    //         // Input for WRAP_ETH command\\n    //         // Parameters: (address recipient, uint256 amountMinimum)\\n    //         inputs[0] = abi.encode(\\n    //             address(UNIVERSAL_ROUTER), // Recipient - the router itself needs the WETH\\n    //             msg.value // Amount to wrap - all the ETH sent\\n    //         );\\n\\n    //         // Construct the path for the swap in reverse order for exact output swaps: TOKEN -> WETH\\n    //         bytes memory path = abi.encodePacked(PAYMENT_TOKEN, UNISWAP_FEE, WETH);\\n\\n    //         // Input for V3_SWAP_EXACT_OUT command\\n    //         // Parameters: (address recipient, uint256 amountOut, uint256 amountInMaximum, bytes path, bool payerIsUser)\\n    //         inputs[1] = abi.encode(\\n    //             RECIPIENT, // Recipient of USDC\\n    //             PAYMENT_AMOUNT, // Exact amount of USDC to receive\\n    //             msg.value, // Maximum amount of WETH to spend\\n    //             path,\\n    //             false // payerIsUser: false since we've have given WETH via UNWRAP already\\n    //         );\\n\\n    //         // Input for UNWRAP_WETH command\\n    //         // Parameters: (address recipient, uint256 amountMinimum)\\n    //         inputs[2] = abi.encode(\\n    //             msg.sender, // Recipient of unwrapped ETH (the original caller)\\n    //             0 // Minimum amount to unwrap (0 means unwrap all remaining WETH)\\n    //         );\\n\\n    //         // Execute the swap through Universal Router\\n    //         UNIVERSAL_ROUTER.execute{value: msg.value}(commands, inputs, deadline);\\n\\n    //         _mint(msg.sender, to, referrer, data);\\n\\n    //         // Call permit on USDC to approve this contract to spend the user's tokens\\n    //         IERC20Permit(address(PAYMENT_TOKEN)).permit(\\n    //             msg.sender, // owner\\n    //             address(this), // spender\\n    //             amount, // value\\n    //             deadline, // deadline\\n    //             v,\\n    //             r,\\n    //             s // signature components\\n    //         );\\n\\n    //         if (PAYMENT_TOKEN.transferFrom(msg.sender, RECIPIENT, PAYMENT_AMOUNT) == false) {\\n    //             revert TransferFailed(PAYMENT_TOKEN, msg.sender, RECIPIENT, PAYMENT_AMOUNT);\\n    //         }\\n    //     } else {\\n    //         freemap[msg.sender] = false;\\n    //     }\\n\\n    //     _mint(msg.sender, to, referrer, data);\\n    // }\\n\\n    function purchase(\\n        address payable to,\\n        uint96 subID,\\n        bytes calldata data,\\n        address payable extraNativeTokenRecipient,\\n        uint256 extraNativeTokenAmount,\\n        address referrer\\n    ) external payable {\\n        uint256 paymentAmount = msg.value;\\n        if (extraNativeTokenRecipient != address(0)) {\\n            paymentAmount -= extraNativeTokenAmount;\\n            extraNativeTokenRecipient.transfer(extraNativeTokenAmount);\\n        }\\n        if (!freemap[msg.sender]) {\\n            if (paymentAmount != PAYMENT_AMOUNT) {\\n                revert WrongPaymentAmount(paymentAmount, PAYMENT_AMOUNT);\\n            }\\n            // TODO RECIPIENT support sending it to destination\\n            RECIPIENT.transfer(paymentAmount);\\n        } else {\\n            freemap[msg.sender] = false;\\n            if (paymentAmount != 0) {\\n                revert WrongPaymentAmount(paymentAmount, 0);\\n            }\\n        }\\n\\n        _mint(msg.sender, to, subID, referrer, data);\\n    }\\n\\n    function addToFreeMap(address[] calldata addresses) external {\\n        if (msg.sender != FREE_MAP_ADMIN) {\\n            revert NotFreeMapAdmin(msg.sender, FREE_MAP_ADMIN);\\n        }\\n\\n        for (uint256 i = 0; i < addresses.length; i++) {\\n            freemap[addresses[i]] = true;\\n        }\\n    }\\n\\n    function removeFromFreeMap(address[] calldata addresses) external {\\n        if (msg.sender != FREE_MAP_ADMIN) {\\n            revert NotFreeMapAdmin(msg.sender, FREE_MAP_ADMIN);\\n        }\\n\\n        for (uint256 i = 0; i < addresses.length; i++) {\\n            freemap[addresses[i]] = false;\\n        }\\n    }\\n\\n    function _mint(address sender, address payable to, uint96 subID, address referrer, bytes calldata data) internal {\\n        uint256 tokenID = _executeMint(to, subID, data);\\n        emit Mint(sender, to, referrer, tokenID);\\n    }\\n\\n    function _executeMint(address to, uint96 subID, bytes calldata data) internal virtual returns (uint256 tokenID);\\n}\\n\",\"keccak256\":\"0xb0fc013afeaae057a8f38a8d040eab7456e63847c776f673d83619d49b01e3f5\",\"license\":\"MIT\"}},\"version\":1}",
  "storageLayout": {
    "storage": [
      {
        "astId": 2458,
        "contract": "project/src/avatars/AvatarsSale.sol:AvatarsSale",
        "label": "freemap",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_bool)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      }
    }
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "solcInput": "{\n  \"language\": \"Solidity\",\n  \"sources\": {\n    \"solc_0.8/proxy/EIP173Proxy.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Proxy.sol\\\";\\n\\ninterface ERC165 {\\n    function supportsInterface(bytes4 id) external view returns (bool);\\n}\\n\\n///@notice Proxy implementing EIP173 for ownership management\\ncontract EIP173Proxy is Proxy {\\n    // ////////////////////////// EVENTS ///////////////////////////////////////////////////////////////////////\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    // /////////////////////// CONSTRUCTOR //////////////////////////////////////////////////////////////////////\\n\\n    constructor(\\n        address implementationAddress,\\n        address ownerAddress,\\n        bytes memory data\\n    ) payable {\\n        _setOwner(ownerAddress);\\n        _setImplementation(implementationAddress, data);\\n    }\\n\\n    // ///////////////////// EXTERNAL ///////////////////////////////////////////////////////////////////////////\\n\\n    function owner() external view returns (address) {\\n        return _owner();\\n    }\\n\\n    function supportsInterface(bytes4 id) external view returns (bool) {\\n        if (id == 0x01ffc9a7 || id == 0x7f5828d0) {\\n            return true;\\n        }\\n        if (id == 0xFFFFFFFF) {\\n            return false;\\n        }\\n\\n        ERC165 implementation;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            implementation := sload(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc)\\n        }\\n\\n        // Technically this is not standard compliant as ERC-165 require 30,000 gas which that call cannot ensure\\n        // because it is itself inside `supportsInterface` that might only get 30,000 gas.\\n        // In practise this is unlikely to be an issue.\\n        try implementation.supportsInterface(id) returns (bool support) {\\n            return support;\\n        } catch {\\n            return false;\\n        }\\n    }\\n\\n    function transferOwnership(address newOwner) external onlyOwner {\\n        _setOwner(newOwner);\\n    }\\n\\n    function upgradeTo(address newImplementation) external onlyOwner {\\n        _setImplementation(newImplementation, \\\"\\\");\\n    }\\n\\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable onlyOwner {\\n        _setImplementation(newImplementation, data);\\n    }\\n\\n    // /////////////////////// MODIFIERS ////////////////////////////////////////////////////////////////////////\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == _owner(), \\\"NOT_AUTHORIZED\\\");\\n        _;\\n    }\\n\\n    // ///////////////////////// INTERNAL //////////////////////////////////////////////////////////////////////\\n\\n    function _owner() internal view returns (address adminAddress) {\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            adminAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\\n        }\\n    }\\n\\n    function _setOwner(address newOwner) internal {\\n        address previousOwner = _owner();\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            sstore(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103, newOwner)\\n        }\\n        emit OwnershipTransferred(previousOwner, newOwner);\\n    }\\n}\\n\"\n    },\n    \"solc_0.8/proxy/Proxy.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// EIP-1967\\nabstract contract Proxy {\\n    // /////////////////////// EVENTS ///////////////////////////////////////////////////////////////////////////\\n\\n    event ProxyImplementationUpdated(address indexed previousImplementation, address indexed newImplementation);\\n\\n    // ///////////////////// EXTERNAL ///////////////////////////////////////////////////////////////////////////\\n\\n    receive() external payable virtual {\\n        revert(\\\"ETHER_REJECTED\\\"); // explicit reject by default\\n    }\\n\\n    fallback() external payable {\\n        _fallback();\\n    }\\n\\n    // ///////////////////////// INTERNAL //////////////////////////////////////////////////////////////////////\\n\\n    function _fallback() internal {\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            let implementationAddress := sload(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc)\\n            calldatacopy(0x0, 0x0, calldatasize())\\n            let success := delegatecall(gas(), implementationAddress, 0x0, calldatasize(), 0, 0)\\n            let retSz := returndatasize()\\n            returndatacopy(0, 0, retSz)\\n            switch success\\n            case 0 {\\n                revert(0, retSz)\\n            }\\n            default {\\n                return(0, retSz)\\n            }\\n        }\\n    }\\n\\n    function _setImplementation(address newImplementation, bytes memory data) internal {\\n        address previousImplementation;\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            previousImplementation := sload(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc)\\n        }\\n\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            sstore(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc, newImplementation)\\n        }\\n\\n        emit ProxyImplementationUpdated(previousImplementation, newImplementation);\\n\\n        if (data.length > 0) {\\n            (bool success, ) = newImplementation.delegatecall(data);\\n            if (!success) {\\n                assembly {\\n                    // This assembly ensure the revert contains the exact string data\\n                    let returnDataSize := returndatasize()\\n                    returndatacopy(0, 0, returnDataSize)\\n                    revert(0, returnDataSize)\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\n    },\n    \"solc_0.8/proxy/EIP173ProxyWithReceive.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./EIP173Proxy.sol\\\";\\n\\n///@notice Proxy implementing EIP173 for ownership management that accept ETH via receive\\ncontract EIP173ProxyWithReceive is EIP173Proxy {\\n    constructor(\\n        address implementationAddress,\\n        address ownerAddress,\\n        bytes memory data\\n    ) payable EIP173Proxy(implementationAddress, ownerAddress, data) {}\\n\\n    receive() external payable override {}\\n}\\n\"\n    }\n  },\n  \"settings\": {\n    \"optimizer\": {\n      \"enabled\": true,\n      \"runs\": 999999\n    },\n    \"outputSelection\": {\n      \"*\": {\n        \"*\": [\n          \"abi\",\n          \"evm.bytecode\",\n          \"evm.deployedBytecode\",\n          \"evm.methodIdentifiers\",\n          \"metadata\",\n          \"devdoc\",\n          \"userdoc\",\n          \"storageLayout\",\n          \"evm.gasEstimates\"\n        ],\n        \"\": [\n          \"ast\"\n        ]\n      }\n    },\n    \"metadata\": {\n      \"useLiteralContent\": true\n    }\n  }\n}",
  "solcInputHash": "4a46ee6c1a29be400c9fab1ecc28e172",
  "argsData": "0x0000000000000000000000007737a9ee363d0b938d8ae1575b826ee3440eaf5d00000000000000000000000061c461ecc993aadeb7e4b47e96d1b8cc37314b2000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000000",
  "linkedData": {
    "paymentAmount": "10000000000",
    "recipient": "0x61c461ecc993aadeb7e4b47e96d1b8cc37314b20",
    "freeMapAdmin": "0x61c461ecc993aadeb7e4b47e96d1b8cc37314b20"
  },
  "transaction": {
    "hash": "0x672bcdd5a0fa22556b48c431701cd4efb7b312ff8704300339d74d79d4a85d67",
    "origin": "0x61c461ecc993aadeb7e4b47e96d1b8cc37314b20"
  },
  "receipt": {
    "blockHash": "0x9ebd682f1dd5c52a1d8043ce92f9feff0eac4b7e73c35893ea4c1d30dd3932b6",
    "blockNumber": "0x7d0b7b",
    "transactionIndex": "0x1"
  },
  "immutableReferences": {
    "2448": [
      {
        "length": 32,
        "start": 496
      },
      {
        "length": 32,
        "start": 1967
      }
    ],
    "2450": [
      {
        "length": 32,
        "start": 361
      },
      {
        "length": 32,
        "start": 1303
      },
      {
        "length": 32,
        "start": 1387
      }
    ],
    "2452": [
      {
        "length": 32,
        "start": 142
      },
      {
        "length": 32,
        "start": 1457
      }
    ],
    "2454": [
      {
        "length": 32,
        "start": 426
      },
      {
        "length": 32,
        "start": 554
      },
      {
        "length": 32,
        "start": 658
      },
      {
        "length": 32,
        "start": 879
      },
      {
        "length": 32,
        "start": 983
      }
    ]
  },
  "inputSourceName": "project/src/avatars/AvatarsSale.sol"
}